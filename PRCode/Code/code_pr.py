# -*- coding: utf-8 -*-
"""Code_PR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CXl4fJkwnZkcak6Lp-LbiS4UMo3OUyi5
"""

import io

import numpy as np
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

from scipy.stats import kendalltau

df=pd.read_csv("C:\PR Code\Datasets\Graph 1.csv")

N = nx.from_pandas_edgelist(df,source='i',target='j',edge_attr='t',create_using=nx.DiGraph())

N.number_of_nodes()

N.number_of_edges()

list2=sorted([0.00000000e+00,
       0.00000000e+00, 1.70068027e-05, 0.00000000e+00, 1.70068027e-05,
       4.25170068e-05, 0.00000000e+00, 1.22236395e-04, 0.00000000e+00,
       0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,
       0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,
       1.12279606e-04, 0.00000000e+00, 2.55102041e-05, 0.00000000e+00,
       0.00000000e+00, 0.00000000e+00, 1.70068027e-05, 2.55102041e-05,
       8.50340136e-06, 0.00000000e+00, 0.00000000e+00, 6.65738234e-05,
       0.00000000e+00, 3.40136054e-05, 0.00000000e+00, 5.10204082e-05,
       0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 8.50340136e-06,
       0.00000000e+00, 0.00000000e+00, 1.17594232e-04, 0.00000000e+00,
       0.00000000e+00, 3.40136054e-05, 5.10204082e-05, 0.00000000e+00,
       1.70068027e-05, 0.00000000e+00])



pg=nx.pagerank(N)
listpg=pg.values()
list3=sorted(list(listpg))

coeff,p = kendalltau(list3,list2)
print("Static PR and temporal betweenness rank = %.8f" % coeff)

bet=nx.betweenness_centrality(N, weight='t')

def number_of_flow(node):
    den=0
    scc=list(N.successors(node))
    pdr=list(N.predecessors(node))
    for n in pdr:
        inc=N.get_edge_data(n,node)
        for s in scc:
            outg=N.get_edge_data(node,s) 
            if inc.get('t')< outg.get('t'):
                den=den+1
            else:
                den=den
    return den



def number_of_inpaths(node,nextn):
    num1=0
    scc=list(N.successors(node))
    pdr=list(N.predecessors(node))
    
    for n in pdr:
        itime=N.get_edge_data(n,node).get('t')
        otime=N.get_edge_data(node,nextn).get('t')
        if itime < otime and N.has_edge(n,node) and N.has_edge(node,nextn):
            num1=num1+1
        else:
            num1=num1
    return num1
            
    
    
def number_of_outpaths(node,prnode):
    num2=0
    scc=list(N.successors(node))
    pdr=list(N.predecessors(node))
    for s in scc:
        itime=N.get_edge_data(prnode,node).get('t')
        otime=N.get_edge_data(node,s).get('t')
        if itime < otime and N.has_edge(prnode,node) and N.has_edge(node,s):
            num2=num2+1
        else:
            num2=num2
    return num2



def factor(node,n):
    out=N.out_degree()
    ind=N.in_degree()
    succ=list(N.successors(n))
    pred=list(N.predecessors(n))
    nin=len(list(N.in_edges(n)))
    nout=len(list(N.out_edges(n)))
    denom=number_of_flow(node)
    if out(node)==0 or ind(node)==0 or bet.get(node)==0 or denom==0:
        frac=0
    else:
        if node in list(N.predecessors(n)):
            numer = number_of_inpaths(node,n)
        if node in list(N.successors(n)):
            numer=number_of_outpaths(node,n)
        frac=numer/denom
            
    return frac





iklist=[]
print("Page Rank Values:\n")
print("Iteration 0 :")
print(bet)
iter1={}
rank=[]
rankpk=[]
sum=0
for n in list(bet.keys()):
  if bet.get(n) == 0:
      page=0
  else: 
      predL=list(N.predecessors(n))
      succL=list(N.successors(n))
      pro=0
      pri=0
      for i in range(0,len(succL)):
        pr1=bet.get(succL[i]) * factor (succL[i],n)
        pro=pro+pr1
      for i in range(0,len(predL)):
        pr2 = bet.get(predL[i]) * factor (predL[i],n)
        pri=pr2+pri  
      page=pro + pri
  ans1={n:page}
  iter1.update(ans1)
print("\nIteration 1 :")
print(iter1)
l1=sorted(list(iter1.values()))
l2=sorted(list(bet.values()))
coeff1,p = kendalltau(l1,l2)
print("rank = %.8f" % coeff1)
coeff2,p = kendalltau(l1,list2)
print("rank 2 = %.8f" % coeff2)
rankpk.append(coeff1*100)
rank.append(coeff2*100)
for k in range(2,11):
  sum=0
  iter2={ }
  for n in list(bet.keys()):
    if iter1.get(n) == 0:
        page=0
    else: 
        predL=list(N.predecessors(n))
        succL=list(N.successors(n))
        pro=0
        pri=0
        for i in range(0,len(succL)):
            pr1=iter1.get(succL[i]) * factor (succL[i],n)
            pro=pro+pr1
        for i in range(0,len(predL)):
            pr2 = iter1.get(predL[i]) * factor (predL[i],n)
            pri=pr2+pri
        page=pro + pri
    ans2={n:page}
    iter2.update(ans2)
    diff=iter2.get(n)-iter1.get(n)
    sum=sum+diff
  iklist.append(sum)
  print("\nIteration",k,":")
  print(iter2)
  print("Ik",k,"=",sum)
  l1=sorted(list(iter2.values()))
  l2=sorted(list(iter1.values()))
  iter1=iter2
  coeff1,p = kendalltau(l1,l2)
  print("rank = %.8f" % coeff1)
  coeff2,p = kendalltau(l1,list2)
  print("rank 2 = %.8f" % coeff2)
  rank.append(coeff2*100)
  rankpk.append(coeff1*100)
print("\n\nIk list:",iklist)
print("\n\nRank list:",rankpk)
print("\n\nRank 2 list:",rank)



list1=sorted(list(iter2.values()))

coeff,p = kendalltau(list1,list2)
print("rank = %.8f" % coeff)

coeff,p = kendalltau(list1,list3)
print("Rank btw 2 PR values = %.8f" % coeff)

indices=[]
for i in range(1,11):
  indices.append(i)
yaxis=[]
for j in range(0,110,10):
  yaxis.append(j)

indices

fig, ax=plt.subplots()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.plot([1,2,3,4,5,6,7,8,9], iklist, color='g')
plt.xticks([1,2,3,4,5,6,7,8,9])
plt.xlabel("Iteration")
plt.ylabel("Ik")
plt.title("Ik v/s k")
plt.show()
print("Ik list: [-0.11254, -0.02230, -0.01083, -0.00335, -0.010113, -0.00181, -0.0089, -0.000913, -0.007981]")

fig, ax=plt.subplots()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.plot(indices, rank, color='b')
plt.xticks(indices)
plt.yticks(yaxis)
plt.xlabel("Iteration")
plt.ylabel("Rank coefficient")
plt.title("Rank coeff percentage(BW and Pr(k)) v/s iteration")
plt.show()
print("Rank 2 list: [96.8148, 91.726, 91.726, 91.726, 91.895, 91.895, 91.895, 91.895, 91.895, 91.895]")



fig, ax=plt.subplots()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.plot(indices, rankpk, color='r')
plt.xticks(indices)
plt.yticks(yaxis)
plt.xlabel("Iteration")
plt.ylabel("Rank coefficient")
plt.title("Rank coeff percentage (PR(k) & PR(k-1)) v/s iteration")
plt.show()
print("Rank list: [88.635, 94.387, 100.0, 100.0, 99.818, 100.0, 100.0, 100.0, 100.0, 100.0]")

dfpr = pd.read_csv("C:\PR Code\Temporal PageRank Values\tpr_graph1.csv")

listpr=sorted(list(dfpr['value']))
list4=[0.0,0.0,0.0,0.0,0.1275,
 0.1275,
 0.1275,
 0.1275,
 0.127608267,
 0.127608267,
 0.15,
 0.15,
 0.15,
 0.15,
 0.15,
 0.15,
 0.235766625,
 0.2775,
 0.277608267,
 0.277700371,
 0.3,
 0.3,
 0.3,
 0.32787123,
 0.363266625,
 0.405,
 0.40500021700000005,
 0.405108467,
 0.4275,
 0.4275,
 0.4275,
 0.45,
 0.45520123,
 0.45520123,
 0.494125355,
 0.513266625,
 0.5325,
 0.5326082670000001,
 0.535966826,
 0.555000108,
 0.5775,
 0.62153325,
 0.640766625,
 0.6440333420000001,
 0.72989181,
 0.963266625,
 2.077136939]

coeff,p = kendalltau(list1,list4)
print("rank btw Temporal and modified page rank  = %.8f" % (coeff*100))

coeff,p = kendalltau(list2,list4)
print("rank btw Temporal page rank and temopral betweenness centrality  = %.8f" % (coeff*100))

